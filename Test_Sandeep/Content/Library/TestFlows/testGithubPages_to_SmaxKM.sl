########################################################################################################################
#!!
#! @description: This is a Python operation and associated functions developed for Market-4616 - Enhance Github Pages Integration to Utilize Github Tagging.
#!               This queries SMAX Service Definitions to get all records where fields - MarketPlaceWikiTag_c and GitHubRepoAndOwnerPageURL_c are not null. Based on the repoOwner, repoNames, and tags, it will then query GitHub and retrieve all the pages matching that information and either Create or Update or Delete the SMAX KM Articles.
#!               Assumptions:
#!               All page content for GitHub Pages are in the "content/en" folder
#!               Within the "content/en" folder and sub-folders if there exists a file, "_index.md", then a webpage exists - This is the standard followed in the organization.
#!               High-Level steps involved to get all the webpages from GitHub pages:
#!               1. API call to GitHub pages to a repo to get the "html_url" /repos/{owner}/{repo}/pages
#!               2. Get a repository: /repos/{owner}/{repo} This will return the details of the repository including parameter that indicates if it has Pages ("has_pages") or not, and the URL ("contents_url") for content folder.
#!               3. Taking the "contents_url" from step #2, use Get to get the trees value from "git_url" from which we can retrieve the subfolders (extract path and url, if trees array contains - "path": "<name other than '_index.md'>") and sub-pages (if trees array contains - "path": "_index.md").
#!               4. If step #3 has "path": "_index.md", then Get pages (webpage) for that path (in first iteration it will be the main page. If part of sub-folders and the name has spaces, replace with "-" to use in Get method) using the "html_url" in step #1 (if it's part of the subfolder, append the hyphenated subfolder name to "html_url".
#!               5. From the webpage retrieved, check if Tags exist/ match as per tag url ("<protocol>://pages.<github_url>/<repo_name>/tags/<tag>/"). If it matches with tag specified in SMAX Service Definition, then Create SMAX Knowledge article. Else, skip.
#!               6. If step #3 does not have "path": "_index.md", then repeat steps #3, #4 and #5 to drill down into subfolders and get to "path": "_index.html".
#!               7. Repeat steps #3, #4, #5 and #6 for all subfolders until there are no more.
#!!#
########################################################################################################################
namespace: TestFlows
operation:
  name: testGithubPages_to_SmaxKM
  inputs:
    - github_host: "${get_sp('Cerner.DigitalFactory.MarketPlace.github_host')}"
    - github_user: "${get_sp('Cerner.DigitalFactory.MarketPlace.github_user')}"
    - github_password: "${get_sp('Cerner.DigitalFactory.MarketPlace.github_password')}"
    - github_protocol: "${get_sp('Cerner.DigitalFactory.MarketPlace.github_protocol')}"
    - smax_baseurl: "${get_sp('Cerner.DigitalFactory.SMAX.smaxURL')}"
    - smax_tenantId: "${get_sp('Cerner.DigitalFactory.SMAX.tenantID')}"
    - smax_token
  python_action:
    use_jython: false
    script: "#################################################################################################\r\n#   OO operation for synchronizing GITHUB all Pages of a Repo and Smax\r\n#   Operation: ExtractGitHUBContentXLoadSMAX\r\n#   Author: Rakesh Sharma Cerner (rakesh.sharma@cerner.com)\r\n#   Inputs:\r\n#       - github_host\r\n#       - github_protocol\r\n#       - github_user\r\n#       - github_password\r\n#       - conf_password\r\n#       - smax_baseurl\r\n#       - smax_tenantId\r\n#       - smax_token\r\n#       - smax_service\r\n#\r\n#   Outputs:\r\n#       - result\r\n#       - message\r\n#       - errorType\r\n#       - errorSeverity\r\n#       - errorProvider\r\n#-----------------------------------\r\n#   Code Updated on Aug-18-2022\r\n#   Updated by: Sandeep Yesudas (sandeep.yesudas@cerner.com)\r\n#   Changes:\r\n#       The updated code now gets all the pages associated to repo(s) and\r\n#       checks tags match with the tags (comma separated values)\r\n#       specified in SMAX Service Definition.\r\n#   Inputs and Outputs defined above remain the same.\r\n#-----------------------------------\t\t\r\n#\tSMAX Service Definition fields used to get GitHub Pages:\r\n#  \t-------------\r\n#\t1. MarketPlaceWikiTag_c (contains the comma separated tags for matching)\r\n#       example: Docker,Ruby\r\n#\t2. GitHubRepoAndOwnerPageURL_c (contains repoOwner,repoName with \"||\" if\r\n#\t\t\t\t\t\t\t\t\tmultiple repoOwner,repoName values)\r\n#       example: digital-factory,digital-factory.github.cerner.com||eod,eod.github.cerner.com\r\n#################################################################################################\r\n\r\n\r\nfrom hashlib import new\r\nimport sys, os\r\nimport subprocess\r\n\r\n# function do download external modules to python \"on-the-fly\"\r\ndef install(param):\r\n    message = \"\"\r\n    result = \"\"\r\n    try:\r\n\r\n        pathname = os.path.dirname(sys.argv[0])\r\n        message = os.path.abspath(pathname)\r\n        message = subprocess.call([sys.executable, \"-m\", \"pip\", \"list\"])\r\n        message = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", param], capture_output=True)\r\n        result = \"True\"\r\n    except Exception as e:\r\n        message = e\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message}\r\n\r\n\r\n# requirement external modules\r\ninstall(\"requests\")\r\ninstall(\"lxml\")\r\ninstall(\"gh-md-to-html\")\r\n\r\n\r\n# main function\r\ndef execute(github_host, github_user, github_password, github_protocol, smax_baseurl, smax_tenantId, smax_token):\r\n    message = \"\"\r\n    result = \"False\"\r\n    errorType = \"\"\r\n    errorSeverity = \"\"\r\n    smax_article_hash_list = \"\"\r\n    SourceSystem = \"CernerGitHUB\"\r\n    SMAX_studio_app = \"Article\"\r\n    dmsg = \"\"\r\n    errorProvider = \"\"\r\n    smax_ext_id_list = \"\"\r\n    extid_smaxid_articlehash = \"\"\r\n    service_article_list = \"\"\r\n    new_external_id_list = \"\"\r\n    errorMessage = ''\r\n\r\n    try:\r\n        confRes = buildConfig(smax_baseurl, smax_tenantId, smax_token)\r\n        if confRes[\"result\"] == \"True\" and confRes[\"github_pages\"]:\r\n            repoPagesAndTags = confRes[\"github_pages\"]\r\n            # Get Github Old Articles SMAX ID and Hash\r\n            foldRes = FindOldArticlesForSourceSystem(smax_baseurl, smax_tenantId, smax_token, SourceSystem)\r\n            if foldRes[\"result\"] == \"True\":\r\n                #smax_article_hash_list = foldRes[\"smax_article_hash_list\"]\r\n                #smax_ids_n_article_hash_json = foldRes[\"smax_ids_n_article_hash\"]\r\n                smax_ext_id_list = foldRes[\"smax_ext_id_list\"]\r\n                extid_smaxid_articlehash = foldRes[\"extid_smaxid_articlehash\"]\r\n            else:\r\n                message = foldRes[\"message\"]\r\n            reposNotFound = []\r\n            allReposTagsList = repoPagesAndTags.split('♪♪')\r\n            for reposTagsList in allReposTagsList:\r\n                pages = reposTagsList.split(\"♪\")\r\n                gitRepoTags = pages[1].split(\",\")\r\n                reposList = pages[0]\r\n                repos = reposList.split(\"||\")\r\n                sdIdRepo = repos[0]\r\n                sdIdRepoList = sdIdRepo.split(\",\")\r\n                serviceDefinitionId = sdIdRepoList[0]\r\n                sdIdRepoList.pop(0)\r\n                repos.pop(0)\r\n                repos.insert(0, \",\".join(sdIdRepoList))\r\n                allRepoPages = []\r\n                gitRepoTagsCheckList = []\r\n                \r\n                for repoOwnerNameAll in repos:\r\n                    repoOwnerName = repoOwnerNameAll.split(\",\")\r\n                    repoOwner = repoOwnerName[0]\r\n                    repoName = repoOwnerName[1]\r\n                    lastRepo = repos[len(repos)-1]\r\n                    contGetPages = \"false\"\r\n                    gitPagesapi_url = '{0}://{1}/api/v3/repos/{2}/{3}/pages'.format(github_protocol, github_host, repoOwner,\r\n                                                                                       repoName)\r\n                    #allRepoPages = []\r\n                    getUrlResp = getGitHubReqUrl(gitPagesapi_url, github_user, github_password)\r\n                    if getUrlResp[\"result\"] == 'True':\r\n                        hurl = getUrlResp[\"jsonResp\"][\"html_url\"][:-1]\r\n                        allRepoPages.append(hurl)\r\n                        contGetPages = \"True\"\r\n                        if not gitRepoTagsCheckList:\r\n                            gitRepoTagsCheckList = [hurl+'/tags/'+rtags for rtags in gitRepoTags]\r\n                        else:\r\n                            newTagsCheckList = [hurl+'/tags/'+rtags for rtags in gitRepoTags]\r\n                            gitRepoTagsCheckList = newTagsCheckList + gitRepoTagsCheckList\r\n                    elif getUrlResp[\"result\"] != 'True' and repoOwnerNameAll != lastRepo:\r\n                        reposNotFound.append(repoOwnerNameAll)\r\n                        continue\r\n                    else:\r\n                        reposNotFound.append(repoOwnerNameAll)\r\n                    if contGetPages == \"True\":\r\n                        gitContentsapi_url = '{0}://{1}/api/v3/repos/{2}/{3}/contents/content/'.format(github_protocol, github_host, repoOwner,\r\n                                                                                       repoName)\r\n                        getContentUrlResp = getGitHubReqUrl(gitContentsapi_url, github_user, github_password)\r\n                        contenturl = ''\r\n                        contGetPages == \"False\"\r\n                        if getContentUrlResp[\"result\"] == 'True':\r\n                            jsonContent = getContentUrlResp[\"jsonResp\"][0]\r\n                            contenturl = jsonContent[\"git_url\"]\r\n                            gittreeapi_url = '{0}:?recursive=true'.format(contenturl)\r\n                        if contenturl != '':\r\n                            gitcontenttreeresp = getGitHubReqUrl(gittreeapi_url, github_user, github_password)\r\n                            if gitcontenttreeresp[\"result\"] == 'True':\r\n                                gitTrees = gitcontenttreeresp[\"jsonResp\"]\r\n                                treeArray = gitTrees.get('tree')\r\n                                for treeElement in treeArray:\r\n                                    if \"_index.md\" in treeElement.get('path') and \"tags/\" not in treeElement.get('path'):\r\n                                        gitSubPage = treeElement.get('path')\r\n                                        #print(\"gitSubPage value is: \" + gitSubPage)\r\n                                        if gitSubPage != \"_index.md\":\r\n                                            subPageVal = hurl+'/'+gitSubPage[:-10].replace(\" \", \"-\").lower()\r\n                                            allRepoPages.append(subPageVal)\r\n                    lastValue = repos[len(repos)-1]\r\n                    if repoOwnerNameAll == lastValue and allRepoPages:\r\n                        #print(\"Call the function to loop through list to get pages and action in SMAX. The list is: \" + str(allRepoPages))\r\n                        ghRepoPageContent = getGithubPages(allRepoPages, github_user, github_password, gitRepoTagsCheckList, serviceDefinitionId)\r\n                        if ghRepoPageContent[\"result\"] == 'True':\r\n                            service_article_list = ghRepoPageContent[\"service_article_list\"]+service_article_list\r\n                            new_external_id_list = ghRepoPageContent[\"new_external_id_list\"]+new_external_id_list\r\n                        else:\r\n                            msg = ghRepoPageContent[\"message\"]\r\n                            result = ghRepoPageContent[\"result\"]\r\n                            errorProvider = 'GITHUB'\r\n                            raise Exception(msg)\r\n            if service_article_list and new_external_id_list:\r\n                smax_data = prepareSMAXData(SMAX_studio_app,service_article_list,new_external_id_list,smax_ext_id_list,extid_smaxid_articlehash,SourceSystem)\r\n                dataI = smax_data[\"smaxDataInsert\"]\r\n                dataU = smax_data[\"smaxDataUpdate\"]\r\n                dataD = smax_data[\"smaxDataDelete\"]\r\n                if len(dataI.strip()):\r\n                    print(\"inside IF to Process dataI\")\r\n                    response_data = processSMAXData(smax_baseurl,smax_tenantId,smax_token,dataI)\r\n                    if response_data[\"result\"] == 'True':\r\n                        dmsg = '{} Records Inserted'.format(response_data[\"records\"])\r\n                if len(dataU.strip()):\r\n                    print(\"inside IF to Process dataU\")\r\n                    response_data = processSMAXData(smax_baseurl,smax_tenantId,smax_token,dataU)\r\n                    if response_data[\"result\"] == 'True':\r\n                        if dmsg:\r\n                            dmsg += ':'\r\n                            dmsg = '{} Records Update'.format(response_data[\"records\"])\r\n                if len(dataD.strip()):\r\n                    print(\"inside IF to Process dataID\")\r\n                    response_data = processSMAXData(smax_baseurl,smax_tenantId,smax_token,dataD)\r\n                    if response_data[\"result\"] == 'True':\r\n                        if dmsg:\r\n                            dmsg += ':'\r\n                            dmsg += ' {} Records Deleted'.format(response_data[\"records\"])\r\n                if len(dmsg.strip()):\r\n                    result = \"True\"\r\n                    message = \"SMAX GitHUB Sync process state: \" + dmsg\r\n                elif not len(dmsg.strip()):\r\n                    dmsg = \"No records found to process\"  # + str(response_data[\"message\"]) + str(response_data[\"smax_message\"])\r\n                    result = \"True\"\r\n                    message = \"SMAX GitHUB Sync process state: \" + dmsg\r\n        elif confRes[\"result\"] == \"True\" and not confRes[\"github_pages\"]:\r\n                result = 'True'\r\n                message = \"No Github pages to sync to SMAX\"\r\n        else:\r\n                msg = 'Cannot Open Connection to SMAX, Wrong URL or Wrong User password or SMAX not Available:' + str(confRes[\"message\"])\r\n                errorType = 'e20000'\r\n                raise Exception(msg)\r\n\r\n    except Exception as e:\r\n        message = str(e)\r\n        result = \"False\"\r\n        errorMessage = message\r\n        errorType = 'e20000'\r\n        result = \"False\"\r\n        if not errorProvider:\r\n            errorProvider = 'SMAX'\r\n        errorSeverity = \"ERROR\"\r\n    return {\"result\": result, \"message\": message, \"errorType\": errorType, \"errorSeverity\": errorSeverity,\"errorProvider\": errorProvider,\"errorMessage\":errorMessage}\r\n\r\n# search github repo owner, repo and pages info  for Service\r\ndef buildConfig(smax_baseurl, tenantId, token):\r\n    message = \"\"\r\n    result = \"False\"\r\n    github_pages = \"\"\r\n\r\n    try:\r\n        import requests\r\n        import json\r\n\r\n        authHeaders = {\"TENANTID\": \"keep-alive\"}\r\n        cookies = {\"SMAX_AUTH_TOKEN\": token}\r\n        #turl = smax_baseurl + \"/rest/\" + tenantId + \"/ems/ServiceDefinition?layout=Id,DisplayLabel,Category,MarketPlaceWikiTag_c,GitHubRepoAndOwnerPageURL_c&filter=GitHubRepoAndOwnerPageURL_c%21%3D''\"\r\n        turl = smax_baseurl + \"/rest/\" + tenantId + \"/ems/ServiceDefinition?layout=Id,DisplayLabel,Category,MarketPlaceWikiTag_c,GitHubRepoAndOwnerPageURL_c&filter=(GitHubRepoAndOwnerPageURL_c%21%3D''+and+MarketPlaceWikiTag_c%21%3D'')\"\r\n        response3 = requests.get(turl, headers=authHeaders, cookies=cookies)\r\n\r\n        if response3.status_code == 200:\r\n            jdata = json.loads(response3.text)\r\n            for ent in jdata['entities']:\r\n                github_pages += ent[\"properties\"][\"Id\"] + \",\"\r\n                github_pages += ent[\"properties\"][\"GitHubRepoAndOwnerPageURL_c\"]\r\n                github_pages += \"♪\" + ent[\"properties\"][\"MarketPlaceWikiTag_c\"] + \"♪♪\"\r\n\r\n            result = \"True\"\r\n        else:\r\n            result = \"False\"\r\n            message = \"Invalid response from Provider: \" + str(response3.content)\r\n\r\n        if len(github_pages) > 0:\r\n            github_pages = github_pages[:-2]\r\n            message = \"Successfully retrieved Github Repo and pages info\"\r\n        else:\r\n            message = \"No Github pages to sync to SMAX\"\r\n    except Exception as e:\r\n        message = e\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"github_pages\": github_pages}\r\n\r\n# Get request to Github - passing URL and credentials for the request. Returns result, message and JSON content.\r\ndef getGitHubReqUrl(gitapi_url, gituser, gitpass):\r\n    import requests\r\n    import json\r\n    message = \"\"\r\n    result = \"False\"\r\n    try:\r\n        basicAuthCredentials = (gituser, gitpass)\r\n        gitresponse = requests.request(\"GET\", gitapi_url,  auth=basicAuthCredentials)\r\n        if gitresponse.status_code == 200:\r\n            jr = json.loads(gitresponse.content)\r\n            result = 'True'\r\n        else:\r\n            jr = \"\"\r\n            message = \"Unsupported response from Provider: \" + str(gitresponse.content) + ': Github Repo & Page:' + str(gitapi_url)\r\n            result = \"False\"\r\n    except Exception as e:\r\n        message = str(e) + ': ' + str(response.text) + ' :URL:' +str(gitapi_url)\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"jsonResp\": jr}\r\n\r\n\r\n\r\n# search function for Confluence\r\ndef FindOldArticlesForSourceSystem(smax_baseurl, tenantId, token, SourceSystem):\r\n    message = \"\"\r\n    result = \"False\"\r\n    smax_ids_n_article_hash = \"\"\r\n    smax_article_hash_list = \"\"\r\n    smax_ext_id_list = \"\"\r\n    extid_smaxid_articlehash = \"\"\r\n\r\n    try:\r\n        import requests\r\n        import json\r\n\r\n        authHeaders = {\"TENANTID\": \"keep-alive\"}\r\n        cookies = {\"SMAX_AUTH_TOKEN\": token}\r\n        turl = smax_baseurl + \"/rest/\" + tenantId + \"/ems/Article?layout=Id,SourceSystem_c,Title,PhaseId,ExternalId,ArticleHash_c&filter=SourceSystem_c%3D'\" + SourceSystem + \"'\"\r\n        response3 = requests.get(turl, headers=authHeaders, cookies=cookies)\r\n\r\n        if response3.status_code == 200:\r\n            jdata = json.loads(response3.text)\r\n            if jdata[\"meta\"][\"total_count\"] >0:\r\n\r\n                for entity in jdata['entities']:\r\n                    if entity[\"properties\"][\"ExternalId\"]:\r\n                        #smax_article_hash_list += entity[\"properties\"][\"ArticleHash_c\"] + \",\"\r\n                        smax_ext_id_list += entity[\"properties\"][\"ExternalId\"] + \",\"\r\n                        #smax_ids_n_article_hash += '\"' + entity[\"properties\"][\"ArticleHash_c\"] + '\":'\r\n                        #smax_ids_n_article_hash += entity[\"properties\"][\"Id\"] + ','\r\n                        extid_smaxid_articlehash += '\"' + entity[\"properties\"][\"ExternalId\"] + '\":'\r\n                        extid_smaxid_articlehash += '\"' + entity[\"properties\"][\"Id\"] + '||' + entity[\"properties\"][\"ArticleHash_c\"] + '\",'\r\n                if smax_ext_id_list:\r\n                    ## create list of external id list\r\n                    smax_ext_id_list = smax_ext_id_list[:-1]\r\n                    ## Create dictionalry of Hash and SMAX IDs for Articles\r\n                    #smax_ids_n_article_hash = '{' + smax_ids_n_article_hash[:-1] + '}'\r\n                    extid_smaxid_articlehash = '{' + extid_smaxid_articlehash[:-1] + '}'\r\n                result = \"True\"\r\n                message = \"Retrieved old articles ID and Hash Successfully\"\r\n            else:\r\n                result = \"True\"\r\n                message = \"No Articles exists in the SMAX\"\r\n        else:\r\n            result = \"False\"\r\n            message = \"Invalid response from Provider: \" + str(response3.content)\r\n\r\n    except Exception as e:\r\n        message = e\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"smax_ext_id_list\": smax_ext_id_list,\r\n            \"extid_smaxid_articlehash\": extid_smaxid_articlehash}\r\n\r\n# Get the Github Pages for specific repos and Owners\r\ndef getGithubPages(githubPageList, github_user, github_password, github_page_tags, smaxService):\r\n\r\n    message = \"\"\r\n    result = \"False\"\r\n    new_article_hash_list = \"\"\r\n    service_article_list = \"\"\r\n    new_external_id_list = \"\"\r\n\r\n    try:\r\n        import requests\r\n        import json\r\n\r\n        basicAuthCredentials = (github_user, github_password)\r\n        #smax_article_hash_list = smax_article_hash_list.split(\",\")\r\n\r\n        for githubPageLink in githubPageList:\r\n            gitapi_url = githubPageLink\r\n            response = requests.request(\"GET\", gitapi_url,  auth=basicAuthCredentials)\r\n            tresponse = response.text\r\n            if response.status_code == 200:\r\n                if any(tagsPath in tresponse for tagsPath in github_page_tags):\r\n                    result = 'True'\r\n                    article_content = response.text\r\n                    title = article_content.split(\"<title>\")[1].split(\"</title>\")[0]\r\n                    article_body = getHTML(article_content, gitapi_url)[\"outHTML\"]\r\n                    # generate hash of Article URL as external ID\r\n                    external_id = createHash(gitapi_url)[\"hash_object\"]\r\n                    new_external_id_list += external_id + \",\"\r\n                    article_hash_response = createHash(article_body)\r\n                    article_hash = article_hash_response[\"hash_object\"]\r\n                    #new_article_hash_list += article_hash + \",\"\r\n                    #if article_hash not in smax_article_hash_list:\r\n                    service_article_list += smaxService + \"♪\" + external_id + \"♪\" + title + \"♪\" + article_hash + \"♪\" + article_body + \"♪♪\"\r\n            else:\r\n                message = \"Unsupported response from Provider: \" + str(response.content) + ': Github Repo & Page URL:' + str(gitapi_url)\r\n                result = \"False\"\r\n        if len(new_external_id_list) >0:\r\n            new_external_id_list = new_external_id_list[:-1]\r\n            service_article_list = service_article_list[:-2]\r\n    except Exception as e:\r\n        message = str(e) + ': ' + str(response.text) + ' :URL:' +str(gitapi_url)\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"service_article_list\": service_article_list,\r\n            \"new_external_id_list\": new_external_id_list}\r\n\r\n# Content hash function\r\ndef createHash(inputString):\r\n    message = \"\"\r\n    result = \"\"\r\n    hash_object = \"\"\r\n    try:\r\n        import hashlib\r\n        # Assumes the default UTF-8\r\n        hash_object = hashlib.md5(inputString.encode()).hexdigest()\r\n        result = \"True\"\r\n    except Exception as e:\r\n        message = e\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"hash_object\": hash_object}\r\n\r\n\r\ndef prepareSMAXData(SMAX_studio_app,service_article_list,new_external_id_list,smax_ext_id_list,extid_smaxid_articlehash,SourceSystem):\r\n    message = \"\"\r\n    result = \"\"\r\n    smaxDataInsert = \"\"\r\n    smaxDataUpdate = \"\"\r\n    smaxDataDelete = \"\"\r\n    description = \"Content from Cerner GITHUB\"\r\n\r\n    try:\r\n        import requests\r\n        import json\r\n\r\n        new_external_id_list = new_external_id_list.split(\",\")\r\n        smax_ext_id_list = smax_ext_id_list.strip().split(\",\")\r\n\r\n        # Create data for insert in SMAX\r\n        smaxDataI = {}\r\n        smaxDataI['entities'] = []\r\n        smaxDataI['operation'] = \"CREATE\"\r\n        # Create data for Update in SMAX\r\n        smaxDataU = {}\r\n        smaxDataU['entities'] = []\r\n        smaxDataU['operation'] = \"UPDATE\"\r\n        # Create data for Update in SMAX\r\n        smaxDataD = {}\r\n        smaxDataD['entities'] = []\r\n        smaxDataD['operation'] = \"DELETE\"\r\n        if extid_smaxid_articlehash:\r\n            extid_smaxid_articlehash = json.loads(extid_smaxid_articlehash)\r\n\r\n        ## Prepare data for insert\r\n        if service_article_list:\r\n            articles = service_article_list.split(\"♪♪\")\r\n            smaxDataI['entities'] = [0] * len(articles)\r\n            smaxDataU['entities'] = [0] * len(articles)\r\n            ii = 0\r\n            i = 0\r\n            for article in articles:\r\n                data = article.split(\"♪\")\r\n                service = data[0]\r\n                new_ext_id = data[1]\r\n                title = data[2]\r\n                article_hash = data[3]\r\n                article_body = data[4]\r\n                if new_ext_id not in smax_ext_id_list:\r\n                    smaxDataI['entities'][ii] = {}\r\n                    smaxDataI['entities'][ii][\"entity_type\"] = SMAX_studio_app\r\n                    smaxDataI['entities'][ii][\"properties\"] = {}\r\n                    smaxDataI['entities'][ii][\"properties\"][\"Service\"] = service\r\n                    smaxDataI['entities'][ii][\"properties\"][\"ExternalId\"] = new_ext_id\r\n                    smaxDataI['entities'][ii][\"properties\"][\"Title\"] = title\r\n                    smaxDataI['entities'][ii][\"properties\"][\"Content\"] = article_body\r\n                    smaxDataI['entities'][ii][\"properties\"][\"Description\"] = description\r\n                    smaxDataI['entities'][ii][\"properties\"][\"ArticleContent\"] = description\r\n                    smaxDataI['entities'][ii][\"properties\"][\"ArticleHash_c\"] = article_hash\r\n                    smaxDataI['entities'][ii][\"properties\"][\"Subtype\"] = \"Article\"\r\n                    smaxDataI['entities'][ii][\"properties\"][\"SourceSystem_c\"] = SourceSystem\r\n                    smaxDataI['entities'][ii][\"properties\"][\"PhaseId\"] = \"External\"\r\n                    smaxDataI['entities'][ii][\"related_properties\"] = {}\r\n                    ii += 1\r\n                elif new_ext_id in smax_ext_id_list:\r\n                    smax_id_articlehash = extid_smaxid_articlehash[new_ext_id]\r\n                    smax_id = smax_id_articlehash.split(\"||\")[0]\r\n                    smax_articlehash = smax_id_articlehash.split(\"||\")[1]\r\n                    if smax_articlehash != article_hash:\r\n                        smaxDataU['entities'][i] = {}\r\n                        smaxDataU['entities'][i][\"entity_type\"] = SMAX_studio_app\r\n                        smaxDataU['entities'][i][\"properties\"] = {}\r\n                        smaxDataU['entities'][i][\"properties\"][\"Id\"] = smax_id\r\n                        smaxDataU['entities'][i][\"properties\"][\"Service\"] = service\r\n                        smaxDataU['entities'][i][\"properties\"][\"ExternalId\"] = new_ext_id\r\n                        smaxDataU['entities'][i][\"properties\"][\"Title\"] = title\r\n                        smaxDataU['entities'][i][\"properties\"][\"Content\"] = article_body\r\n                        smaxDataU['entities'][i][\"properties\"][\"Description\"] = description\r\n                        smaxDataU['entities'][i][\"properties\"][\"ArticleContent\"] = description\r\n                        smaxDataU['entities'][i][\"properties\"][\"ArticleHash_c\"] = article_hash\r\n                        smaxDataU['entities'][i][\"properties\"][\"Subtype\"] = \"Article\"\r\n                        smaxDataU['entities'][i][\"properties\"][\"SourceSystem_c\"] = SourceSystem\r\n                        smaxDataU['entities'][i][\"properties\"][\"PhaseId\"] = \"External\"\r\n                        smaxDataU['entities'][i][\"related_properties\"] = {}\r\n                        i += 1\r\n\r\n        # Prepare data for  delete  Article records\r\n       # smax_article_hashs = smax_article_hash_list.split(\",\")\r\n        smaxDataD['entities'] = [0] * len(smax_ext_id_list)\r\n\r\n        i = 0\r\n        if smax_ext_id_list:\r\n            for ext_id in smax_ext_id_list:\r\n                if ext_id:\r\n                    if ext_id not in new_external_id_list:\r\n                        smax_id_articlehash = extid_smaxid_articlehash[ext_id]\r\n                        smax_id = smax_id_articlehash.split(\"||\")[0]\r\n                        smaxDataD['entities'][i] = {}\r\n                        smaxDataD['entities'][i][\"entity_type\"] = SMAX_studio_app\r\n                        smaxDataD['entities'][i][\"properties\"] = {}\r\n                        smaxDataD['entities'][i][\"properties\"][\"Id\"] = smax_id\r\n                        i += 1\r\n\r\n        # remove null items\r\n        smaxDataI = removenull_fm_dict(smaxDataI)[\"output\"]\r\n        smaxDataU = removenull_fm_dict(smaxDataU)[\"output\"]\r\n        smaxDataD = removenull_fm_dict(smaxDataD)[\"output\"]\r\n\r\n        if len(smaxDataI['entities']) <1:\r\n            smaxDataI = \"\"\r\n        else:\r\n            smaxDataInsert = json.dumps(smaxDataI)\r\n\r\n        if len(smaxDataU['entities']) <1:\r\n            smaxDataU = \"\"\r\n        else:\r\n            smaxDataUpdate = json.dumps(smaxDataU)\r\n\r\n        if len(smaxDataD['entities']) <1:\r\n            smaxDataD = \"\"\r\n        else:\r\n            smaxDataDelete = json.dumps(smaxDataD)\r\n\r\n        message = 'Data Prepared for Insert Update and Delete in SMAX'\r\n        result = \"True\"\r\n    except Exception as e:\r\n        message = e\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"smaxDataInsert\": smaxDataInsert,  \"smaxDataUpdate\": smaxDataUpdate,\"smaxDataDelete\": smaxDataDelete}\r\n\r\ndef removenull_fm_dict(input):\r\n    result = \"False\"\r\n    message = \"\"\r\n    output = \"\"\r\n    try:\r\n        ii = len(input['entities'])\r\n        i = 0\r\n        a = 0\r\n        while i < ii:\r\n            if input['entities'][a] == 0:\r\n                del input['entities'][a]\r\n                a -= 1\r\n            i += 1\r\n            a += 1\r\n        output = input\r\n        result = \"True\"\r\n        message = \"Input processed and null values removed\"\r\n\r\n    except Exception as e:\r\n        result = \"False\"\r\n        message = \"Failed to clean NULL Values: \" + str(e)\r\n\r\n    return {\"result\":result,\"message\":message,\"output\":output}\r\n\r\n# insert or update or delete data from SMAX\r\ndef processSMAXData(smax_baseurl, tenantId, token, dataS):\r\n    message = \"\"\r\n    result = \"False\"\r\n    smax_message = ''\r\n\r\n    try:\r\n        import requests\r\n        import json\r\n\r\n        headers = {\r\n            'Cookie': 'LWSSO_COOKIE_KEY=' + token,\r\n            'Content-Type': 'application/json',\r\n            'User-Agent': 'Apache-HttpClient/4.4.1'\r\n        }\r\n\r\n        payload = dataS\r\n        url = smax_baseurl + \"/rest/\" + tenantId + \"/ems/bulk\"\r\n\r\n        response = requests.request(\"POST\", url, headers=headers, data=payload)\r\n        message = response.text\r\n        mresponse = json.loads(response.text)\r\n\r\n        if response.status_code == 200:\r\n            result_list = mresponse[\"entity_result_list\"]\r\n            i = 0\r\n            for rr in result_list:\r\n                if rr[\"completion_status\"] == \"OK\":\r\n                    i += 1\r\n\r\n            smax_message = \"{} Records Affected!\".format(i)\r\n            records = i\r\n            result = \"True\"\r\n        else:\r\n            smax_message = \"Issue Processing Records! Check syntax or body or SMAX availability\"\r\n\r\n\r\n    except Exception as e:\r\n        message = e\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"smax_response\": smax_message,\"records\": records}\r\n\r\n\r\n# HTML convertion for Confluence HTML content\r\ndef getHTML(inHTML, link):\r\n    message = \"\"\r\n    result = \"\"\r\n    outHTML = \"\"\r\n\r\n    try:\r\n\r\n        from lxml import html, etree\r\n        import gh_md_to_html\r\n        # print(\"     Processing: \" + link)\r\n        link_template = \"<div><p>Original page can be found at: <a href=\\\"\" + link + \"\\\">\" + link + \"</a>&nbsp;</p><div><br/>\"\r\n        xslt_text = \"<xsl:stylesheet version=\\\"1.0\\\"\\r\\n xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\"\\r\\n xmlns:xhtml=\\\"http://www.w3.org/1999/xhtml\\\">\\r\\n <xsl:output omit-xml-declaration=\\\"yes\\\" indent=\\\"yes\\\"/>\\r\\n <xsl:strip-space elements=\\\"*\\\"/>\\r\\n\\r\\n <xsl:template match=\\\"p|div|br|a|h1|h2|h3|li|ul|ol|u|strong|table|td|tr|img|span|@*\\\">\\r\\n     <xsl:copy>\\r\\n       <xsl:apply-templates select=\\\"node()|@*\\\"/>\\r\\n     </xsl:copy>\\r\\n </xsl:template>\\r\\n\\r\\n <xsl:template match=\\\"code\\\"/>\\r\\n</xsl:stylesheet>\"\r\n\r\n        inHTML = gh_md_to_html.markdown_to_html_via_github_api(inHTML)\r\n        xslt_doc = etree.fromstring(xslt_text)\r\n        inHTML = inHTML.replace(\"\\n\", \"\").replace(\"\\t\", \"\")\r\n        transform = etree.XSLT(xslt_doc)\r\n        ehtml = html.fromstring(inHTML)\r\n        docs = etree.tostring(ehtml)\r\n        result = transform(ehtml)\r\n\r\n        docs = etree.tostring(result)\r\n        #docs = str(result)\r\n\r\n        outHTMLraw = link_template + str(bytes.decode(docs).replace(\"\\&quot;\", \"\").replace(\"\\\\n\", \"\").replace(\"&#194;&#160;\", \"&nbsp;\").replace(\"&lt;\", \"<\").replace(\"&gt;\", \">\")) + \" \"\r\n        #outHTML = link_template + str(docs).replace(\"\\&quot;\", \"\").replace(\"\\\\n\", \"\").replace(\"&#194;&#160;\", \"&nbsp;\").replace(\r\n         #       \"&lt;\", \"<\").replace(\"&gt;\", \">\") + \" \"\r\n        outHTML = pageCleanup(outHTMLraw)[\"outHTML\"]\r\n        # print(\"     Processing +DONE+\\n\")\r\n        result = \"True\"\r\n    except Exception as e:\r\n        message = e\r\n        print(message)\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"outHTML\": outHTML}\r\n    # return inHTML\r\n\r\n#Below function is used for cleaning Search bar and empty bullet points from the GitHub Pages before updating/ deleting SMAX Article\r\ndef pageCleanup(HTMLraw):\r\n    message = \"\"\r\n    result = \"\"\r\n    outHTML = \"\"\r\n\r\n    try:\r\n         #---- This section removes the search bar content from html page------\r\n        startString = '<p>type=\"search\"class='\r\n        endString = 'data-offline-search-max-results=\"10\"</div>'\r\n        endString2 = 'data-offline-search-max-results=\"10\"<ul>'\r\n        if HTMLraw.find(startString) > 0:\r\n            start_index = HTMLraw.index(startString)\r\n            if HTMLraw.find(endString) > 0:\r\n                end_index = HTMLraw.index(endString)+41\r\n                HTMLraw2 = HTMLraw[0: start_index:] + HTMLraw[end_index + 1::]\r\n            elif HTMLraw.find(endString2) > 0:\r\n                end_index = HTMLraw.index(endString2)+35\r\n                HTMLraw2 = HTMLraw[0: start_index:] + HTMLraw[end_index + 1::]\r\n            else:\r\n                HTMLraw2 =  HTMLraw\r\n        else:\r\n            HTMLraw2 =  HTMLraw\r\n         #------ clean search bar ends here------------------------------------\r\n         #---- This section removes the empty bullet points from html page------\r\n        startStringBullet = '<p>Last modified'\r\n        endStringBullet = '</p>'\r\n        if HTMLraw2.find(startStringBullet) > 0:\r\n            start_indexB = HTMLraw2.index(startStringBullet)\r\n            if HTMLraw2.rfind(endStringBullet) > start_indexB:\r\n                end_indexB = HTMLraw2.rindex(endStringBullet)+4\r\n                outHTML = HTMLraw2[0: end_indexB:] + '</div>'\r\n            else:\r\n                outHTML =  HTMLraw2\r\n        else:\r\n            outHTML =  HTMLraw2\r\n         #------ clean empty bullet points ends here------------------------------------\r\n    except Exception as e:\r\n        message = e\r\n        print(message)\r\n        result = \"False\"\r\n    return {\"result\": result, \"message\": message, \"outHTML\": outHTML}"
  outputs:
    - result
    - message
    - errorType
    - errorSeverity
    - errorProvider
    - errorMessage
  results:
    - SUCCESS: "${result=='True'}"
    - FAILURE
